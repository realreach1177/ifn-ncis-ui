<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Connection Web — Full (Preserved + Enhancements)</title>

<!-- Firebase (compat) -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>

<style>
:root{
  --bg:#0f1113; --panel:#1c1c1c; --muted:#99aacc; --accent:#66aaff;
}
html,body{height:100%;margin:0;background:var(--bg);color:#e6eef6;font-family: "Segoe UI", Roboto, system-ui, -apple-system;overflow:hidden;}
/* Toolbar */
#toolbar{position:fixed;top:12px;left:50%;transform:translateX(-50%);width:92%;max-width:1200px;background:var(--panel);padding:10px;border-radius:12px;display:flex;justify-content:space-between;align-items:center;gap:12px;z-index:1200;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
.toolbar-left,.toolbar-right{display:flex;align-items:center;gap:8px}
.toolbar-left button,.toolbar-right button{padding:8px 12px;border-radius:8px;border:none;cursor:pointer;font-weight:700;color:#fff;background:#2f3941}
#addProfileBtn{background:#3949ab}
#addTextBtn{background:#6a1b9a}
#deleteSelectedBtn{background:#7b3d3d}
#undoBtn,#redoBtn{background:#455a64}
#searchBox{background:#23282d;border-radius:8px;padding:8px 10px;color:#cfe6ff;border:none;min-width:180px}

/* right group */
#webNameInput,#webListDropdown{background:#21272b;border-radius:8px;padding:8px 10px;color:#dfefff;border:none}
#saveWebBtn{background:#2e7d32}
#loadWebBtn{background:#1565c0}
#deleteWebBtn{background:#c62828}

/* Stage & viewport */
#stage{position:absolute;inset:0;cursor:grab;background:
  linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
  linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
  background-size:40px 40px}
#viewport{position:absolute;left:0;top:0;width:100%;height:100%;transform-origin:0 0;overflow:visible}
svg#wires{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:1}
#cards{position:absolute;left:0;top:0;width:100%;height:100%;z-index:2}

/* Card */
.card{position:absolute;background:#202126;border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6);color:#eaf6ff;cursor:grab;min-width:300px;display:flex;gap:12px;align-items:flex-start;z-index:10}
.card.textNode{min-width:auto;background:transparent;color:#77aaff;font-weight:700;padding:6px 12px;box-shadow:none}
.card .img{width:68px;height:68px;border-radius:50%;object-fit:cover;border:3px solid rgba(255,255,255,0.06)}
.card .info{flex:1}
.card .name{font-size:18px;font-weight:800;color:var(--accent);margin-bottom:4px}
.card .rank{font-weight:700;color:#cfe6ff;margin-bottom:6px}
.card .faction{display:inline-block;padding:6px 10px;border-radius:8px;background:#233a54;color:#dff1ff;font-weight:700;margin-bottom:8px}
.card .desc{margin-top:8px;color:#9fbfdc;font-size:13px}
.file-list{margin-top:8px;padding-left:18px;color:#8fbfe0;font-size:13px;max-height:90px;overflow:auto}
.anchor{position:absolute;width:14px;height:14px;border-radius:50%;background:#ffd54f;border:2px solid #222;top:-8px;left:50%;transform:translate(-50%,-50%);cursor:crosshair;box-shadow:0 1px 6px rgba(0,0,0,0.5)}

/* Editor */
#editPanel{position:fixed;right:16px;top:72px;width:380px;background:var(--panel);padding:18px;border-radius:12px;z-index:1500;display:none;box-shadow:-8px 16px 40px rgba(0,0,0,0.6)}
#editPanel h3{margin:0 0 10px 0;color:var(--accent);font-size:18px}
#editPanel label{display:block;margin-top:10px;font-weight:700;color:#cfe6ff}
#editPanel input,#editPanel select,#editPanel textarea{width:100%;padding:8px;border-radius:8px;border:none;background:#1b2430;color:#e6f6ff;margin-top:6px}
#editPanel textarea{min-height:80px}
#editPanel .btns{display:flex;gap:8px;margin-top:12px}
#editPanel button{flex:1;padding:10px;border-radius:8px;border:none;cursor:pointer;font-weight:800;color:#fff}
#editPanel .save{background:#2e7d32}#editPanel .cancel{background:#8a4b4b}

/* Minimap */
#minimap{position:fixed;right:18px;bottom:18px;width:240px;height:160px;background:#0f1315;border-radius:10px;border:1px solid #1f2a33;z-index:1400;overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,0.6)}
#minimapSVG{width:100%;height:100%}

/* small helpers */
.toast{position:fixed;left:50%;transform:translateX(-50%);bottom:22px;background:#0b1220;padding:10px 18px;border-radius:8px;color:#fff;z-index:999999;box-shadow:0 6px 20px rgba(0,0,0,0.7)}
.selected{outline:3px solid rgba(255,200,40,0.25);box-shadow:0 0 20px rgba(255,200,40,0.12)}
.dragging{box-shadow:0 0 26px 4px rgba(102,170,255,0.12)}
</style>
</head>
<body>

<div id="toolbar" role="toolbar" aria-label="Main controls">
  <div class="toolbar-left" role="group">
    <button id="addProfileBtn" title="Add Profile (double-click stage too)">Add Profile</button>
    <button id="addTextBtn" title="Add Text Label">Add Text</button>
    <button id="deleteSelectedBtn" title="Delete selected card/textbox">Delete Selected</button>
    <button id="undoBtn" title="Undo (Ctrl+Z)">Undo</button>
    <button id="redoBtn" title="Redo (Ctrl+Y)">Redo</button>
    <input id="searchBox" type="text" placeholder="Search name, branch, rank..." aria-label="Search"/>
  </div>

  <div class="toolbar-right" role="group" aria-label="Workspace controls">
    <input id="webNameInput" type="text" placeholder="Connection Web name" aria-label="Workspace name"/>
    <select id="webListDropdown" aria-label="Saved webs"></select>
    <button id="saveWebBtn">Save</button>
    <button id="loadWebBtn">Load</button>
    <button id="deleteWebBtn">Delete</button>
  </div>
</div>

<div id="stage">
  <div id="viewport">
    <svg id="wires" xmlns="http://www.w3.org/2000/svg" overflow="visible"></svg>
    <div id="cards"></div>
  </div>
</div>

<div id="editPanel" role="dialog" aria-modal="true" aria-hidden="true">
  <h3>Edit Profile</h3>
  <label>Image URL</label><input id="fImage" type="url" placeholder="https://..."/>
  <label>Name</label><input id="fName" type="text" />
  <label>Status</label><select id="fStatus"><option>Unknown</option><option>Alive</option><option>Dead</option></select>
  <label>Faction</label><select id="fFaction"></select>
  <label>Sub-branch</label><input id="fSubbranch" type="text" />
  <label>Rank</label><select id="fRank"></select>
  <label>Details</label><textarea id="fDesc"></textarea>

  <label>Attached files (from DB)</label>
  <select id="selectFiles" multiple size="6" style="width:100%;margin-top:6px;background:#0f1b26;color:#dff1ff;border-radius:6px;padding:6px;"></select>

  <label>External file URL (add)</label><input id="fExternalUrl" type="url" placeholder="https://..." />
  <label>External file display name</label><input id="fExternalName" type="text" placeholder="Optional display name" />

  <label style="margin-top:10px;"><input id="fEnableSnap" type="checkbox" /> Enable snapping for this node</label>

  <div style="display:flex;gap:8px;margin-top:12px;">
    <button id="btnSavePanel" class="save">Save</button>
    <button id="btnCancelPanel" class="cancel">Cancel</button>
  </div>
</div>

<div id="minimap"><svg id="minimapSVG" xmlns="http://www.w3.org/2000/svg"></svg></div>

<script>
/* ======================
   Firebase Initialization
   ====================== */
const firebaseConfig = {
  apiKey: "AIzaSyCIPvPH1loTbzY9MZN6XAoRG7PmUpU4J2I",
  authDomain: "ncis-intranet.firebaseapp.com",
  databaseURL: "https://ncis-intranet-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "ncis-intranet",
  storageBucket: "ncis-intranet.appspot.com",
  messagingSenderId: "1010993365309",
  appId: "1:1010993365309:web:8c72db8c5d95c061adc554",
  measurementId: "G-GLMXRGGSHX"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();
const auth = firebase.auth();
auth.signInAnonymously().catch(()=>{});

/* ======================
   App State
   ====================== */
let cards = {};      // map id -> { id, x, y, data:{...}, isText }
let edges = {};      // map id -> { id, source, target }
let textBoxes = {};  // map id -> { id, x, y, content }
let selectedId = null;
let selectedType = null; // 'node'/'edge'/'text'
let tx = 0, ty = 0, scale = 1;
let undoStack = [], redoStack = [];
let autosave = false;

const stage = document.getElementById('stage');
const viewport = document.getElementById('viewport');
const wires = document.getElementById('wires');
const cardsLayer = document.getElementById('cards');
const minimapSVG = document.getElementById('minimapSVG');
const webListDropdown = document.getElementById('webListDropdown');
const webNameInput = document.getElementById('webNameInput');

/* Branch colors and rank lists (kept) */
const factions = ["None","United States","Army","Navy","Marines","Air Force","Taliban","Al-Qaeda"];
const factionColors = {
  "None":"#777777","United States":"#3f51b5","Army":"#4caf50","Navy":"#2196f3","Marines":"#f44336","Air Force":"#03a9f4","Taliban":"#9c27b0","Al-Qaeda":"#ff9800"
};
const rankLists = {
  "None":["None"],
  "United States":["General","Colonel","Major","Captain","Lieutenant"],
  "Army":["General","Colonel","Major","Captain","Lieutenant"],
  "Navy":["Admiral","Captain","Commander","Lieutenant"],
  "Marines":["General","Colonel","Major","Captain","Lieutenant"],
  "Air Force":["General","Colonel","Major","Captain","Lieutenant"],
  "Taliban":["Leader","Commander","Soldier"],
  "Al-Qaeda":["Leader","Commander"]
};

/* ======================
   Utilities
   ====================== */
function randId(prefix='id'){ return prefix + Math.random().toString(36).slice(2,10); }
function toast(msg, t=1300){ const el = document.createElement('div'); el.className='toast'; el.textContent=msg; document.body.appendChild(el); setTimeout(()=>{ el.style.opacity='0'; setTimeout(()=>el.remove(),300); }, t); }
function fileNameFromUrl(url){ try{ return new URL(url).pathname.split('/').pop()||url }catch{ return (url||'').split('/').pop()||url } }
function applyTransform(){ viewport.style.transform = `translate(${tx}px,${ty}px) scale(${scale})` }

/* convert client coordinates to world (viewport) coordinates */
function clientToWorld(cx,cy){
  const r = stage.getBoundingClientRect();
  const sx = cx - r.left;
  const sy = cy - r.top;
  return { x: (sx - tx) / scale, y: (sy - ty) / scale };
}

/* ======================
   Rendering: cards, textboxes, edges
   ====================== */
function createCardElement(node){
  const el = document.createElement('div');
  el.className = 'card' + (node.isText ? ' textNode' : '');
  el.id = 'card-' + node.id;
  el.style.left = node.x + 'px';
  el.style.top = node.y + 'px';
  // content
  if(node.isText){
    el.innerHTML = `<div class="info"><div class="name">${node.data.name || 'Text'}</div></div>`;
  } else {
    const d = node.data || {};
    el.innerHTML = `<img class="img" src="${d.image || 'https://i.ibb.co/zhKnjbh1/unknownperson.png'}" alt="avatar" />
      <div class="info">
        <div class="name" style="color:${d.branchColor || factionColors[d.faction] || '#66aaff'}">${d.name || 'New Profile'}</div>
        <div class="rank">${d.rank || ''}</div>
        <div class="faction">${d.faction || 'None'}${d.subBranch ? ' — ' + d.subBranch : ''}</div>
        <div class="status"><span class="statusDot ${(d.status||'Unknown').toLowerCase()}"></span> ${d.status || 'Unknown'}</div>
        <div class="description">${d.details || ''}</div>
        <ul class="file-list">${(d.files || []).map(f=>`<li><a href="${f.url}" target="_blank" rel="noopener">${f.name||fileNameFromUrl(f.url)}</a></li>`).join('')}</ul>
      </div>
      <div class="anchor" title="Drag to link"></div>`;
  }

  // click selects and opens editor
  el.addEventListener('click', e => {
    e.stopPropagation();
    selectNode(node.id);
    if(!node.isText) openEditor(node.id);
  });

  // dragging for card
  let dragging = false, offset = {x:0,y:0};
  el.addEventListener('pointerdown', e => {
    if(e.target.classList.contains('anchor')) return; // anchor handled elsewhere
    dragging = true; el.classList.add('dragging'); el.setPointerCapture(e.pointerId);
    const wp = clientToWorld(e.clientX, e.clientY);
    offset.x = wp.x - node.x; offset.y = wp.y - node.y;
  });
  el.addEventListener('pointermove', e => {
    if(!dragging) return;
    const wp = clientToWorld(e.clientX, e.clientY);
    node.x = wp.x - offset.x; node.y = wp.y - offset.y;
    el.style.left = node.x + 'px'; el.style.top = node.y + 'px';
    updateEdges();
  });
  el.addEventListener('pointerup', e => {
    dragging = false; el.classList.remove('dragging'); try{ el.releasePointerCapture(e.pointerId); }catch{}
    snapshot();
  });
  el.addEventListener('pointercancel', e => {
    dragging = false; el.classList.remove('dragging'); try{ el.releasePointerCapture(e.pointerId); }catch{} snapshot();
  });

  cardsLayer.appendChild(el);
  return el;
}

function createTextElement(box){
  const el = document.createElement('div');
  el.className = 'card textNode';
  el.id = 'card-' + box.id;
  el.style.left = box.x + 'px';
  el.style.top = box.y + 'px';
  el.innerHTML = `<div class="info"><div class="name">${box.content || 'Text Label'}</div></div>`;
  el.addEventListener('click', e => { e.stopPropagation(); selectNode(box.id); openEditor(box.id, true); });
  let dragging=false, offset={x:0,y:0};
  el.addEventListener('pointerdown', e=>{ dragging=true; el.classList.add('dragging'); el.setPointerCapture(e.pointerId); const wp = clientToWorld(e.clientX,e.clientY); offset.x = wp.x - box.x; offset.y = wp.y - box.y; });
  el.addEventListener('pointermove', e=>{ if(!dragging) return; const wp = clientToWorld(e.clientX,e.clientY); box.x = wp.x - offset.x; box.y = wp.y - offset.y; el.style.left = box.x + 'px'; el.style.top = box.y + 'px'; });
  el.addEventListener('pointerup', e=>{ dragging=false; el.classList.remove('dragging'); try{ el.releasePointerCapture(e.pointerId);}catch{} snapshot(); });
  cardsLayer.appendChild(el);
  return el;
}

function createEdgeElement(edge){
  const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
  ln.setAttribute('stroke','#9fbfdc'); ln.setAttribute('stroke-width','3'); ln.dataset.eid = edge.id;
  wires.appendChild(ln);
  return ln;
}

function anchorCenter(nodeId){
  const el = document.getElementById('card-'+nodeId);
  if(!el) return null;
  const anchor = el.querySelector('.anchor');
  const rect = anchor.getBoundingClientRect();
  const stageRect = stage.getBoundingClientRect();
  return { x: (rect.left + rect.width/2 - stageRect.left - tx) / scale, y: (rect.top + rect.height/2 - stageRect.top - ty) / scale };
}

function updateEdgePosition(edge){
  const ln = wires.querySelector(`line[data-eid="${edge.id}"]`);
  if(!ln) return;
  const a = anchorCenter(edge.source);
  const b = anchorCenter(edge.target);
  if(!a || !b){ ln.remove(); return; }
  ln.setAttribute('x1', a.x); ln.setAttribute('y1', a.y);
  ln.setAttribute('x2', b.x); ln.setAttribute('y2', b.y);
}

function updateEdges(){
  // ensure svg lines exist
  Object.values(edges).forEach(e=>{
    let ln = wires.querySelector(`line[data-eid="${e.id}"]`);
    if(!ln) ln = createEdgeElement(e);
    updateEdgePosition(e);
  });
}

function renderAll(){
  // clear and rebuild DOM card elements (simple, robust)
  cardsLayer.innerHTML = '';
  wires.innerHTML = '';
  // nodes
  Object.values(cards).forEach(n=>{
    if(n.isText) createTextElement(n);
    else createCardElement(n);
  });
  // edges
  Object.values(edges).forEach(e => createEdgeElement(e));
  updateEdges();
  applyTransform();
  renderMinimapAutoFit();
}

/* ======================
   History: undo/redo
   ====================== */
function snapshot(){
  const state = {
    cards: JSON.parse(JSON.stringify(cards)),
    edges: JSON.parse(JSON.stringify(edges)),
    tx, ty, scale
  };
  undoStack.push(state);
  if(undoStack.length>100) undoStack.shift();
  redoStack = [];
}
function undo(){
  if(!undoStack.length){ toast('Nothing to undo'); return; }
  redoStack.push({cards: JSON.parse(JSON.stringify(cards)), edges: JSON.parse(JSON.stringify(edges)), tx, ty, scale});
  const st = undoStack.pop();
  cards = JSON.parse(JSON.stringify(st.cards));
  edges = JSON.parse(JSON.stringify(st.edges));
  tx = st.tx; ty = st.ty; scale = st.scale;
  renderAll();
  toast('Undo');
}
function redo(){
  if(!redoStack.length){ toast('Nothing to redo'); return; }
  undoStack.push({cards: JSON.parse(JSON.stringify(cards)), edges: JSON.parse(JSON.stringify(edges)), tx, ty, scale});
  const st = redoStack.pop();
  cards = JSON.parse(JSON.stringify(st.cards));
  edges = JSON.parse(JSON.stringify(st.edges));
  tx = st.tx; ty = st.ty; scale = st.scale;
  renderAll();
  toast('Redo');
}

/* ======================
   Selection & Editor
   ====================== */
function selectNode(id){
  // clear previous selection
  if(selectedId){
    const prev = document.getElementById('card-'+selectedId);
    if(prev) prev.classList.remove('selected');
  }
  selectedId = id;
  const el = document.getElementById('card-'+id);
  if(el) el.classList.add('selected');
  selectedType = (cards[id] && cards[id].isText) ? 'text' : 'node';
}

const editPanel = document.getElementById('editPanel');

function openEditor(nodeId, isText=false){
  if(!nodeId) return;
  selectNode(nodeId);
  const node = cards[nodeId];
  // populate selects
  populateFactionSelect();
  // if text node, fill fDesc with content and show minimal UI (we still use same panel, but prefer description)
  if(node.isText){
    document.getElementById('fImage').value = '';
    document.getElementById('fName').value = node.data.name || '';
    document.getElementById('fStatus').value = 'Unknown';
    document.getElementById('fFaction').value = 'None';
    document.getElementById('fSubbranch').value = '';
    document.getElementById('fRank').value = 'None';
    document.getElementById('fDesc').value = node.data.name || '';
    document.getElementById('selectFiles').innerHTML = '';
    document.getElementById('fExternalUrl').value = '';
    document.getElementById('fExternalName').value = '';
    document.getElementById('fEnableSnap').checked = !!node.data.enableSnap;
    editPanel.style.display = 'block';
    editPanel.setAttribute('aria-hidden','false');
    document.getElementById('fName').focus();
    return;
  }
  const d = node.data || {};
  document.getElementById('fImage').value = d.image || '';
  document.getElementById('fName').value = d.name || '';
  document.getElementById('fStatus').value = d.status || 'Unknown';
  populateFactionSelect(d.faction || 'None');
  populateRanks(d.faction || 'None', d.rank || 'None');
  document.getElementById('fSubbranch').value = d.subBranch || '';
  document.getElementById('fRank').value = d.rank || 'None';
  document.getElementById('fDesc').value = d.details || '';
  document.getElementById('fEnableSnap').checked = !!d.enableSnap;
  // populate attached files list (selectFiles)
  populateFilesForSelect(d.files || []).then(()=>{});
  // clear external fields
  document.getElementById('fExternalUrl').value = '';
  document.getElementById('fExternalName').value = '';
  editPanel.style.display = 'block';
  editPanel.setAttribute('aria-hidden','false');
  document.getElementById('fName').focus();
}

function closeEditor(){
  editPanel.style.display = 'none';
  editPanel.setAttribute('aria-hidden','true');
}

/* wire up editor save/cancel */
document.getElementById('btnCancelPanel').addEventListener('click', ()=>{ closeEditor(); });
document.getElementById('btnSavePanel').addEventListener('click', async ()=>{
  if(!selectedId) return;
  const node = cards[selectedId];
  if(!node) return;
  // if text node: save text content into name
  if(node.isText){
    node.data.name = document.getElementById('fName').value.trim();
    // update DOM
    const el = document.getElementById('card-'+node.id);
    if(el) el.querySelector('.name').textContent = node.data.name;
    snapshot();
    renderAll();
    closeEditor();
    return;
  }
  // normal profile
  const img = document.getElementById('fImage').value.trim();
  const name = document.getElementById('fName').value.trim() || 'Unnamed';
  const status = document.getElementById('fStatus').value;
  const faction = document.getElementById('fFaction').value;
  const subBranch = document.getElementById('fSubbranch').value.trim();
  const rank = document.getElementById('fRank').value;
  const details = document.getElementById('fDesc').value.trim();
  const enableSnap = document.getElementById('fEnableSnap').checked;
  // selected files from selectFiles
  const selectedOptions = Array.from(document.getElementById('selectFiles').selectedOptions || []);
  const filesList = selectedOptions.map(o => JSON.parse(o.value));
  // external file
  const extUrl = document.getElementById('fExternalUrl').value.trim();
  const extName = document.getElementById('fExternalName').value.trim() || fileNameFromUrl(extUrl);
  if(extUrl) filesList.push({ url: extUrl, name: extName });
  // assign
  node.data = node.data || {};
  node.data.image = img;
  node.data.name = name;
  node.data.status = status;
  node.data.faction = faction;
  node.data.subBranch = subBranch;
  node.data.rank = rank;
  node.data.details = details;
  node.data.files = filesList;
  node.data.enableSnap = enableSnap;
  node.data.branchColor = factionColors[faction] || '#777';
  // persist to Firebase node path
  await db.ref('orgchart/nodes/'+node.id).set(node);
  // update UI
  snapshot();
  renderAll();
  closeEditor();
});

/* ======================
   populateFiles: gathers files from suspects, insurgents, confidential_informants
   returns promise that resolves when selectFiles is filled
   ====================== */
async function populateFilesForSelect(selectedFiles = []){
  const sel = document.getElementById('selectFiles');
  sel.innerHTML = '<option disabled>Loading...</option>';
  try{
    const [susSnap, insSnap, ciSnap] = await Promise.all([
      db.ref('suspects').get(),
      db.ref('insurgents').get(),
      db.ref('confidential_informants').get()
    ]);
    const files = [];
    [susSnap, insSnap, ciSnap].forEach(snap => {
      if(!snap.exists()) return;
      const val = snap.val();
      Object.keys(val).forEach(k=>{
        const v = val[k];
        if(v && v.docUrl){
          files.push({ url: v.docUrl, name: (v.target ? v.target + ' [' + (v.creator || '') + ']' : fileNameFromUrl(v.docUrl)) });
        }
      });
    });
    sel.innerHTML = '';
    files.forEach(f=>{
      const opt = document.createElement('option');
      opt.value = JSON.stringify(f);
      opt.textContent = f.name || fileNameFromUrl(f.url);
      // select if in selectedFiles
      if(Array.isArray(selectedFiles) && selectedFiles.some(sf => sf.url === f.url)) opt.selected = true;
      sel.appendChild(opt);
    });
    if(files.length === 0) sel.innerHTML = '<option disabled>(no files found)</option>';
  }catch(err){
    sel.innerHTML = '<option disabled>Error loading</option>';
    console.error('populateFiles error', err);
  }
}

/* ======================
   Add / Delete / Text nodes
   ====================== */
document.getElementById('addProfileBtn').addEventListener('click', ()=>{
  const id = randId('n');
  const node = { id, x: 150 + Math.random()*200, y: 150 + Math.random()*200, isText: false, data: { name:'New Profile', image:'https://i.ibb.co/zhKnjbh1/unknownperson.png', faction:'None', rank:'None', subBranch:'', status:'Unknown', details:'', files:[], enableSnap:false } };
  cards[id] = node;
  // add to firebase nodes
  db.ref('orgchart/nodes/'+id).set(node);
  snapshot();
  renderAll();
  openEditor(id);
});

document.getElementById('addTextBtn').addEventListener('click', ()=>{
  const id = randId('t');
  const node = { id, x: 200 + Math.random()*200, y: 200 + Math.random()*200, isText: true, data:{ name: 'Text Label' } };
  cards[id] = node;
  snapshot();
  renderAll();
  openEditor(id, true);
});

document.getElementById('deleteSelectedBtn').addEventListener('click', ()=>{
  if(!selectedId){ alert('Select a node first'); return; }
  if(!confirm('Delete selected item?')) return;
  // delete from firebase if node
  if(cards[selectedId] && !cards[selectedId].isText){
    db.ref('orgchart/nodes/'+selectedId).remove().catch(()=>{});
  }
  // remove edges connected to this id
  Object.keys(edges).forEach(eid=>{
    const e = edges[eid];
    if(e.source === selectedId || e.target === selectedId){
      db.ref('orgchart/edges/'+eid).remove().catch(()=>{});
      delete edges[eid];
    }
  });
  // remove card
  delete cards[selectedId];
  const el = document.getElementById('card-'+selectedId); if(el) el.remove();
  selectedId = null;
  selectedType = null;
  snapshot();
  renderAll();
});

/* ======================
   Anchor drag linking
   ====================== */
let anchorDrag = { active:false, startId:null, tmpLine:null };
stage.addEventListener('pointerdown', e=>{
  const target = e.target;
  if(!target.classList.contains('anchor')) return;
  const cardEl = target.closest('.card');
  if(!cardEl) return;
  anchorDrag.active = true;
  anchorDrag.startId = cardEl.id.replace('card-','');
  // create temporary svg line
  const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
  ln.setAttribute('stroke','#ffd54f'); ln.setAttribute('stroke-width','3'); ln.setAttribute('stroke-linecap','round'); ln.setAttribute('stroke-opacity','0.95');
  wires.appendChild(ln);
  anchorDrag.tmpLine = ln;
  const s = anchorCenter(anchorDrag.startId);
  if(s){ ln.setAttribute('x1', s.x); ln.setAttribute('y1', s.y); ln.setAttribute('x2', s.x); ln.setAttribute('y2', s.y); }
  target.setPointerCapture(e.pointerId);
});
stage.addEventListener('pointermove', e=>{
  if(!anchorDrag.active) return;
  const p = clientToWorld(e.clientX, e.clientY);
  if(anchorDrag.tmpLine){ anchorDrag.tmpLine.setAttribute('x2', p.x); anchorDrag.tmpLine.setAttribute('y2', p.y); }
});
stage.addEventListener('pointerup', e=>{
  if(!anchorDrag.active) return;
  anchorDrag.active = false;
  if(anchorDrag.tmpLine){ anchorDrag.tmpLine.remove(); anchorDrag.tmpLine = null; }
  const el = document.elementFromPoint(e.clientX, e.clientY);
  let targetCard = el ? el.closest('.card') : null;
  if(!targetCard) return;
  const targetId = targetCard.id.replace('card-','');
  if(targetId === anchorDrag.startId) return;
  // prevent duplicate edges
  const exists = Object.values(edges).some(ed => (ed.source === anchorDrag.startId && ed.target === targetId) || (ed.source === targetId && ed.target === anchorDrag.startId));
  if(exists) { toast('Edge exists'); return; }
  const newId = randId('e');
  const edgeObj = { id: newId, source: anchorDrag.startId, target: targetId };
  edges[newId] = edgeObj;
  // persist in Firebase edges
  db.ref('orgchart/edges/'+newId).set(edgeObj);
  snapshot();
  renderAll();
});

/* ======================
   Zoom / Pan
   ====================== */
let isPanning = false, panStart = {x:0,y:0}, panOrigin = {tx:0,ty:0};
stage.addEventListener('pointerdown', e=>{
  // ignore if starting pointer on card or editor or minimap
  if(e.target.closest('.card') || e.target.closest('#editPanel') || e.target.closest('#minimap')) return;
  isPanning = true;
  panStart.x = e.clientX; panStart.y = e.clientY;
  panOrigin.tx = tx; panOrigin.ty = ty;
  stage.style.cursor = 'grabbing';
  stage.setPointerCapture(e.pointerId);
});
stage.addEventListener('pointermove', e=>{
  if(!isPanning) return;
  const dx = e.clientX - panStart.x, dy = e.clientY - panStart.y;
  tx = panOrigin.tx + dx; ty = panOrigin.ty + dy;
  applyTransform();
  updateEdges();
});
stage.addEventListener('pointerup', e=>{
  if(!isPanning) return;
  isPanning = false;
  stage.style.cursor = 'grab';
  try{ stage.releasePointerCapture(e.pointerId); }catch{}
  snapshot();
});
stage.addEventListener('pointercancel', e=>{
  if(!isPanning) return;
  isPanning = false;
  stage.style.cursor = 'grab';
  try{ stage.releasePointerCapture(e.pointerId); }catch{}
  snapshot();
});
stage.addEventListener('wheel', e=>{
  e.preventDefault();
  const zoomFactor = 1.12;
  const mouse = clientToWorld(e.clientX, e.clientY);
  if(e.deltaY < 0) scale *= zoomFactor; else scale /= zoomFactor;
  scale = Math.max(0.25, Math.min(4, scale));
  tx = e.clientX - mouse.x * scale;
  ty = e.clientY - mouse.y * scale;
  applyTransform();
  updateEdges();
}, {passive:false});

/* ======================
   Minimap that fits whole workspace
   ====================== */
function renderMinimapAutoFit(){
  // compute bounding box of nodes and textBoxes
  const nodes = Object.values(cards);
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  nodes.forEach(n=>{
    if(n.x < minX) minX = n.x;
    if(n.y < minY) minY = n.y;
    if(n.x > maxX) maxX = n.x;
    if(n.y > maxY) maxY = n.y;
  });
  if(minX === Infinity){ minX = 0; minY = 0; maxX = stage.clientWidth; maxY = stage.clientHeight; }
  // add padding
  const pad = 200;
  minX -= pad; minY -= pad; maxX += pad; maxY += pad;
  const w = maxX - minX, h = maxY - minY;
  // svg size
  const svgW = minimapSVG.clientWidth || 240, svgH = minimapSVG.clientHeight || 160;
  const scaleMM = Math.min(svgW / w, svgH / h);
  // clear svg
  while(minimapSVG.firstChild) minimapSVG.removeChild(minimapSVG.firstChild);
  // draw edges
  Object.values(edges).forEach(e=>{
    const a = cards[e.source], b = cards[e.target];
    if(!a || !b) return;
    const ln = document.createElementNS('http://www.w3.org/2000/svg','line');
    ln.setAttribute('x1', (a.x - minX) * scaleMM);
    ln.setAttribute('y1', (a.y - minY) * scaleMM);
    ln.setAttribute('x2', (b.x - minX) * scaleMM);
    ln.setAttribute('y2', (b.y - minY) * scaleMM);
    ln.setAttribute('stroke', '#888');
    ln.setAttribute('stroke-width', 1);
    minimapSVG.appendChild(ln);
  });
  // draw nodes
  Object.values(cards).forEach(n=>{
    const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
    rect.setAttribute('x', (n.x - minX) * scaleMM);
    rect.setAttribute('y', (n.y - minY) * scaleMM);
    rect.setAttribute('width', Math.max(6, 36 * Math.min(1, scaleMM)));
    rect.setAttribute('height', Math.max(4, 20 * Math.min(1, scaleMM)));
    rect.setAttribute('fill', (n.data && n.data.branchColor) ? n.data.branchColor : '#555');
    minimapSVG.appendChild(rect);
  });
  // viewport rect representing current translated/scale view
  const viewRect = document.createElementNS('http://www.w3.org/2000/svg','rect');
  const viewX = (-tx - minX*scale) / scale;
  const viewY = (-ty - minY*scale) / scale;
  // But simpler: compute world coords of viewport corners
  const worldTopLeft = { x: (-tx) / scale, y: (-ty) / scale };
  const worldBottomRight = { x: (window.innerWidth - tx) / scale, y: (window.innerHeight - ty) / scale };
  const vx = (worldTopLeft.x - minX) * scaleMM;
  const vy = (worldTopLeft.y - minY) * scaleMM;
  const vw = (worldBottomRight.x - worldTopLeft.x) * scaleMM;
  const vh = (worldBottomRight.y - worldTopLeft.y) * scaleMM;
  viewRect.setAttribute('x', vx);
  viewRect.setAttribute('y', vy);
  viewRect.setAttribute('width', Math.max(1, vw));
  viewRect.setAttribute('height', Math.max(1, vh));
  viewRect.setAttribute('stroke', '#0f0');
  viewRect.setAttribute('stroke-width', 1.5);
  viewRect.setAttribute('fill', 'none');
  minimapSVG.appendChild(viewRect);
}

/* minimap click to pan */
minimapSVG.addEventListener('click', e=>{
  const rect = minimapSVG.getBoundingClientRect();
  const clickX = e.clientX - rect.left, clickY = e.clientY - rect.top;
  // reconstruct minX/minY/w/h as above
  const nodes = Object.values(cards);
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  nodes.forEach(n=>{ if(n.x < minX) minX = n.x; if(n.y < minY) minY = n.y; if(n.x > maxX) maxX = n.x; if(n.y > maxY) maxY = n.y; });
  if(minX === Infinity){ minX = 0; minY = 0; maxX = stage.clientWidth; maxY = stage.clientHeight; }
  const pad=200; minX-=pad; minY-=pad; maxX+=pad; maxY+=pad;
  const w = maxX - minX, h = maxY - minY;
  const svgW = rect.width, svgH = rect.height;
  const scaleMM = Math.min(svgW / w, svgH / h);
  const worldX = minX + clickX / scaleMM;
  const worldY = minY + clickY / scaleMM;
  // center viewport on worldX/worldY
  tx = window.innerWidth/2 - worldX*scale;
  ty = window.innerHeight/2 - worldY*scale;
  applyTransform(); updateEdges(); renderMinimapAutoFit();
});

/* ======================
   Firebase: load orgchart nodes/edges listener
   ====================== */
function listenOrgchart(){
  db.ref('orgchart').on('value', snapshot=>{
    const v = snapshot.val() || {};
    // load nodes
    cards = {};
    if(v.nodes){
      Object.keys(v.nodes).forEach(k=>{
        cards[k] = v.nodes[k];
      });
    }
    // load edges
    edges = {};
    if(v.edges){
      Object.keys(v.edges).forEach(k=>{
        edges[k] = v.edges[k];
      });
    }
    renderAll();
  });
}

/* initial call */
listenOrgchart();

/* ======================
   Workspace Save / Load / Delete
   saved under 'connectionWebs/<name>' with structure { cards, edges, tx, ty, scale }
   ====================== */
async function refreshWorkspaceList(){
  try{
    const snap = await db.ref('connectionWebs').once('value');
    const val = snap.val() || {};
    webListDropdown.innerHTML = '';
    Object.keys(val).sort().forEach(k=>{
      const opt = document.createElement('option'); opt.value = k; opt.textContent = k; webListDropdown.appendChild(opt);
    });
    const last = localStorage.getItem('lastWeb');
    if(last && val[last]){ webListDropdown.value = last; webNameInput.value = last; subscribeToWorkspace(last); }
  }catch(err){ console.error('refreshWorkspaceList', err); }
}

async function saveWorkspace(){
  const name = webNameInput.value.trim();
  if(!name){ alert('Enter a workspace name'); return; }
  // copy objects
  const payload = { cards, edges, tx, ty, scale, updatedAt: Date.now() };
  try{
    await db.ref('connectionWebs/'+name).set(payload);
    toast('Saved workspace: '+name);
    await refreshWorkspaceList();
    localStorage.setItem('lastWeb', name);
  }catch(err){ alert('Save failed: '+err.message); }
}

function subscribeToWorkspace(name){
  if(!name) return;
  if(window.currentWorkspaceListener){
    db.ref('connectionWebs/'+window.currentWorkspaceName).off('value', window.currentWorkspaceListener);
    window.currentWorkspaceListener = null; window.currentWorkspaceName = null;
  }
  const ref = db.ref('connectionWebs/'+name);
  window.currentWorkspaceListener = ref.on('value', snap=>{
    const data = snap.val();
    if(!data){ toast('No data for '+name); return; }
    cards = data.cards || {};
    edges = data.edges || {};
    tx = data.tx || 0; ty = data.ty || 0; scale = data.scale || 1;
    applyTransform(); renderAll();
    toast('Loaded workspace: '+name);
  }, err => {
    alert('Sync failed: '+err.message);
  });
  window.currentWorkspaceName = name;
}

async function loadWorkspace(){
  const name = webNameInput.value.trim() || webListDropdown.value;
  if(!name){ alert('Select a workspace to load'); return; }
  subscribeToWorkspace(name);
  localStorage.setItem('lastWeb', name);
}

async function deleteWorkspace(){
  const name = webListDropdown.value || webNameInput.value.trim();
  if(!name){ alert('Select a workspace to delete'); return; }
  const confirmText = prompt(`Type DELETE to confirm deletion of "${name}"`);
  if(confirmText !== 'DELETE'){ alert('Deletion canceled'); return; }
  try{
    if(window.currentWorkspaceListener && window.currentWorkspaceName === name){
      db.ref('connectionWebs/'+name).off('value', window.currentWorkspaceListener);
      window.currentWorkspaceListener = null; window.currentWorkspaceName = null;
    }
    await db.ref('connectionWebs/'+name).remove();
    toast('Deleted workspace: '+name);
    await refreshWorkspaceList();
  }catch(err){ alert('Delete failed: '+err.message); }
}

/* wire workspace buttons */
document.getElementById('saveWebBtn').addEventListener('click', saveWorkspace);
document.getElementById('loadWebBtn').addEventListener('click', loadWorkspace);
document.getElementById('deleteWebBtn').addEventListener('click', deleteWorkspace);
document.getElementById('webListDropdown').addEventListener('change', e => { const v = e.target.value; if(v){ webNameInput.value = v; localStorage.setItem('lastWeb', v); } });

/* on load, refresh workspace list */
refreshWorkspaceList();

/* ======================
   populate faction/rank selects in editor
   ====================== */
function populateFactionSelect(selected){
  const sel = document.getElementById('fFaction');
  sel.innerHTML = '';
  factions.forEach(f=>{
    const opt = document.createElement('option');
    opt.value = f; opt.textContent = f;
    if(f === selected) opt.selected = true;
    sel.appendChild(opt);
  });
}

function populateRanks(faction, selected){
  const sel = document.getElementById('fRank');
  sel.innerHTML = '';
  (rankLists[faction] || ['None']).forEach(r=>{
    const opt = document.createElement('option');
    opt.value = r; opt.textContent = r;
    if(r === selected) opt.selected = true;
    sel.appendChild(opt);
  });
}
document.getElementById('fFaction').addEventListener('change', e => populateRanks(e.target.value, null));

/* ======================
   Search box
   ====================== */
document.getElementById('searchBox').addEventListener('input', e=>{
  const q = e.target.value.trim().toLowerCase();
  Object.values(cards).forEach(n=>{
    const el = document.getElementById('card-'+n.id);
    if(!el) return;
    const text = ((n.data && (n.data.name + ' ' + n.data.faction + ' ' + (n.data.rank||''))) || (n.data && n.data.name) || '').toLowerCase();
    el.style.display = (!q || text.includes(q)) ? 'flex' : 'none';
  });
});

/* ======================
   Keyboard shortcuts
   ====================== */
window.addEventListener('keydown', e=>{
  if((e.ctrlKey || e.metaKey) && e.key === 'z'){ e.preventDefault(); undo(); }
  if((e.ctrlKey || e.metaKey) && e.key === 'y'){ e.preventDefault(); redo(); }
  if(e.key === 'Delete' || e.key === 'Backspace'){ if(selectedId) document.getElementById('deleteSelectedBtn').click(); }
});

/* ======================
   Realtime: sync individual node/edge changes from firebase to local (optional)
   This app listens to 'orgchart' root once above; to keep both in sync we write when we change.
   ====================== */

/* ======================
   Initial setup: load orgchart once, and render
   ====================== */
function init(){
  // initial render
  renderAll();
  // last web
  const last = localStorage.getItem('lastWeb');
  if(last) { webNameInput.value = last; }
  // keyboard friendly focus
  document.getElementById('addProfileBtn').focus();
}
init();

/* Expose for debugging */
window.__cw = { cards, edges, textBoxes, renderAll, snapshot, undo, redo, saveWorkspace, loadWorkspace, refreshWorkspaceList };

</script>
</body>
</html>
